\documentclass[12pt,a4paper,final]{article}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\author{The INFDEV team}
\title{Homework DEV}
\begin{document}
	\maketitle
	
	\section{DEV1}
			\textbf{TODO}

	\section{DEV2}
		\subsection{Functions}
			\begin{itemize}
				\item Write the \texttt{sumTwo} function that returns the sum between two numbers
				\item Write the \texttt{ageDescription} function that takes as input an age, and returns the description of what can be legally done at that age:
				\begin{itemize}
					\item If the age is smaller than 3, return ``nothing'';
					\item If the age is between 3 and 12, return ``you can shoot semi-automated guns in the USA'';
					\item If the age is between 12 and 16, return ``you can go to high school and think your life is really tough'';
					\item If the age is between 16 and 25, return ``you can go to an HBO and think high school was really easy in comparison'';
					\item If the age is between 25 and 65, return ``you can go to work'';
					\item If the age is more than 65, return ``you can retire now''
				\end{itemize}
				\item Write the \texttt{interval} function that takes as input two integers, and prints all values between them with a loop;
				\item Write the \texttt{intervalRec} function that takes as input two integers, and prints all values between them with recursion;
				\item Write the \texttt{evens} function that takes as input two integers, and prints all even values between them with a loop;
				\item Write the \texttt{evensRec} function that takes as input two integers, and prints all odd values between them with recursion;
				\item Write the \texttt{intervalSum} function that takes as input two integers, and returns the sum of all values between them with a loop;
				\item Write the \texttt{intervalSumRec} function that takes as input two integers, and returns the sum of all values between them with recursion;
			\end{itemize}
	
		\subsection{Data structures}
			\textbf{No reference solutions yet:}
			\textbf{TODO}

		\subsection{Understanding stack and heap}
			\textbf{No reference solutions yet:}
			\textbf{TODO}

		\subsection{Methods}
			\textbf{No reference solutions yet:}
			\textbf{TODO}

		\subsection{Higher order functions}
			\textbf{No reference solutions yet:}
			\textbf{TODO}
						
					
	
		\subsection{Make a car move}
			As said in the introduction. you will first focus on a relevant part.
			Assignment 1 is about cars in a city.
			We already gave you the city, so let's focus on the car.
			
			The relevant concepts are \href{https://github.com/hogeschool/INFDEV02-2/raw/master/Slides/Lecture%20I%20-%20data%20structures.pdf}{classes} and \href{https://github.com/hogeschool/INFDEV02-2/raw/master/Slides/Lecture%20V%20-%20methods.pdf}{methods} (those are links to the slides).
				In (very, very) short: A class is a blueprint which defines what data can be stored.
				An object can be instantiated, and can then store the data you want in attributes.
				Methods can be used to modify that data.

			\paragraph*{Console version}
			\begin{itemize}
				\item Build a \texttt{Car} class;
				\item Add the attribute \texttt{Position}, which will be a simple integer;
				\item Add the \texttt{Move} method that increments the position by one;
				\item Make a test program that initialises the car and moves it ten times; print the position of the car on the console at every step.
			\end{itemize}
		
			\paragraph*{Pygame version}
			\begin{itemize}
				\item Get a template to kick-start your pygame application.
				For example from \href{http://openbookproject.net/thinkcs/python/english3e/pygame.html}{here}.
				Delete code you don't need, so you have a relative clean application to start with.
				\item Draw -- Now add a shape or picture that will represent the car.
				For now you can put it in the game loop.
				Play around a bit with its parameters and make shure you understand how you can move the 'car'.
				\item Now add the \texttt{Car} class from part 1.
				\item Instantiate a car-object.
				\item From within the gameloop, call the move-method on the car
				\item Now use the car-position to change where the car is drawn on the screen.
			\end{itemize}
			
		
		
		\subsection{Make a list of cars move}
			In the assignment you will have more than one car.
			These multiple cars need to be stored in a way that makes it easy to use all these cars programatically.
			For this, we've introduced \href{https://github.com/hogeschool/INFDEV02-2/raw/master/Slides/Lecture%20II%20-%20lists.pdf}{Lists} in the lessons.
				In a list you typically store a lot of objects of the same type (but, it is possible to store any type).
				In this exercise you will combine the Car-objects with lists.
			\paragraph*{Console version}
			\begin{itemize}
				\item Build the \texttt{Node} and \texttt{Empty} classes;
				\item Add the usual attributes \texttt{IsEmpty}, \texttt{Head}, and \texttt{Tail} to the classes;
				\item Make a test program that
				\begin{itemize}
					\item initialises a list of cars,
					\item moves each of them ten times,
					\item print the position of each car on the console at every step.
				\end{itemize}
			\end{itemize}
			
			\paragraph*{Pygame version}
			Expand on the pygame application from exercise 1.
			
			\begin{itemize}
				\item Add a \texttt{VerticalPosition} attribute to the car, so that each car has a different vertical position to distinguish it on the screen;
				\item Use the list of cars you just implemented to draw a pygame screen where various cars move from the left to the right of the screen.
			\end{itemize}
			
		\subsection{Moving along checkpoints}
			In the assignments the cars will not move along positions based on coordinates, but positions based on \textit{tiles} are used.
			In this exercise we will focus on that concept, however we will use a slightly different example: metro's and metro stations.
			Our metro is always at a metro station. It can travel between 2 neighbouring stations, but we will not store any positions in between 2 stations.
			With this exercise you will gain a deeper understanding of Classes, Attributes and Lists.
			The theory and slides from the previous 2 exercises are applied here.
			
			\paragraph*{Console version}
			\begin{itemize}
				\item Make a \texttt{Station} class,
				which contains a \texttt{Position} attribute and a \texttt{Name};
				for example: Station(Position(10,40), "Kralinse zoom")
				\item Make a list of stations;
				\item Make a \texttt{Metro} class,
				which has an attribute \texttt{CurrentStation} and a method \texttt{Move}.
				\item The \texttt{CurrentStation} will store a reference to a node in the list of stations;
				\item In the \texttt{Metro} class, the \texttt{Move} method changes position to the \texttt{Tail}, which is the next checkpoint;
				\item Make a test program that initialises a list of metro's, and moves them until they all reach the final checkpoint; print the position of each metro (which is now a checkpoint) on the console at every step.
			\end{itemize}
			
			Let's reflect on what you did in the part of this exercise.
			The metro (or car) still stores its position, however that position is now abstracted away into a station object.
			This has the advantage that you can reason about station ``kralinse zoom'' for example, instead of (10, 40).
			Station still stores its position in terms of coordinates (10,40), because we will need that to draw the stations in pygame.
			Stations are connected to each other by the linked list. a Node's head (containing station ``kralingse zoom'') is connected to the tail (containing it's neighbour ``Capelse brug'').
			
			
			\paragraph*{Pygame version}
			\begin{itemize}
				\item Draw a pygame screen with the Stations and the Metro's;
				\item The various metro move from one Station to the other.
			\end{itemize}
			
		\subsection{Exercise 4 - crossings}
			Let's continue our voyage by car again. This gives more freedom to travel around the city.
			\paragraph*{Console version}
			\begin{itemize}
				\item Make a \texttt{Node2D} class,
				which contains attributes
				\texttt{Head}, \texttt{TailLeft}, \texttt{TailRight}, \texttt{TailUp}, \texttt{TailDown}, and \texttt{Final};
				this is effectively the same as a list,
				but with four possible choices for the \texttt{Tail} (we call this a \textbf{matrix});
				\item Make a class Crossing, with attributes: Position and Name.
				\item Make a series of crossings and put them into \texttt{Node2D}'s; For example: Rotterdam CS, Hofplein, Eendrachtsplein, Beurs and Blaak.
				\item You have to define which two crossings are connected using the tails. For example: Rotterdam CS's tailRight would be Hofplein.
				\item In the \texttt{Car}, the \texttt{Position} will now be a reference to a \texttt{Node2D} in the matrix of checkpoints;
				\item In the \texttt{Car}, the \texttt{Move} method changes position to one of the \texttt{Tail}s, which is the next chosen checkpoint; the choice can be random;
				\item Make a test program that initialises a list of cars, and moves them until they all reach a specific checkpoint with \texttt{Final == True}; print the position of each car (which is now a checkpoint) on the console at every step.
			\end{itemize}
			
			\paragraph*{Pygame version}
			\begin{itemize}
				\item Draw a pygame screen with the checkpoints and the cars;
				\item The various cars move from one checkpoint to the other (like the cars in the city assignment).
			\end{itemize}
			
		\subsection{Bikes}
			\paragraph*{Console version}
			\begin{itemize}
				\item Make a \texttt{Bike} class that has the \texttt{Move} method just like the car;
				\item Dutch \texttt{Bike}'s are fast, so the bike moves by two tiles at a time;
				\item Add a \texttt{PrintPosition} method to the \texttt{Car} and the \texttt{Bike}, which prints where the vehicle is;
				\item Make a test program that initialises a list contains a mixture of cars and bikes, and moves them until they all reach a specific checkpoint with \texttt{Final == True}; print the position of each car or bike (which is now a checkpoint) on the console at every step.
			\end{itemize}
			
			\paragraph*{Pygame version}
			\begin{itemize}
				\item Add a \texttt{Draw} method to the \texttt{Car} and the \texttt{Bike}, which draws where the vehicle is with the proper texture; the texture is also added as an attribute of both \texttt{Car} and \texttt{Bike};
				\item Draw a pygame screen with the checkpoints, the bikes and the cars;
				\item The various cars and bikes move from one checkpoint to the other (like the cars and boats in the city assignment).
			\end{itemize}
			
		

	\section{DEV3}
		\paragraph{Introduction to object-oriented programming}
		\begin{itemize}
			\item Write an example of Python code that would cause a type error in Java/C\#
			\item Given all semantic and typing rules in the slides, write down down in plain English or Dutch
			\item Write a Java/C\# program featuring
			\begin{itemize}
				\item A \texttt{Counter} class;
				\item With a \texttt{count} integer attribute;
				\item With an empty (parameterless) constructor;
				\item With a method \texttt{Reset};
				\item With a method \texttt{Tick};
				\item (\textbf{Advanced}) With a static method/overloaded operator \texttt{Plus} which adds two counters into one;
				\item (\textbf{Advanced}) With a method \texttt{OnTarget} that takes as input a lambda function which will be fired when the counter reaches a given count.
			\end{itemize}
			\item Make a static function that sums all numbers between two inputs read from the console and prints the result
						
			\item Make an \texttt{Interval} class that:
			\begin{itemize}
				\item takes two integers, \texttt{l} and \texttt{u}, as its constructor parameters
				\item has a \texttt{Sum} method that returns the sum of all numbers between \texttt{l} and \texttt{u}
				\item has a \texttt{Product} method that returns the product of all numbers between \texttt{l} and \texttt{u}
			\end{itemize}
		
		\end{itemize}



		\paragraph{Reuse through polymorphism}
		\begin{itemize}
			\item Write a \texttt{Vehicle} interface with a method \texttt{move} and a method \texttt{loadFuel}; \texttt{loadFuel} accepts a \texttt{Fuel} instance, where \texttt{Fuel} is an interface of your writing; \texttt{move} returns a boolean which is \texttt{true} if there is enough fuel, and \texttt{false} otherwise
			\item Write a concrete class \texttt{Car} and a concrete class \texttt{Gasoline} that implement, respectively, \texttt{Vehicle} and \texttt{Fuel}; the \texttt{Car} checks that the given fuel is indeed \texttt{Gasoline}
			\item Write a concrete class \texttt{Truck} and a concrete class \texttt{Diesel} that implement, respectively, \texttt{Vehicle} and \texttt{Fuel}; the \texttt{Truck} checks that the given fuel is indeed \texttt{Diesel}
			\item Write a concrete class \texttt{Enterprise} and a concrete class \texttt{Dilithium} that implement, respectively, \texttt{Vehicle} and \texttt{Fuel}; the \texttt{Enterprise} checks that the given fuel is indeed \texttt{Dilithium}
			\item Make a program that receives three vehicles, without knowing their concrete type, and moves them (without resorting to conversions) until their fuel is up
		\end{itemize}
		
		\textbf{No reference solution yet:}
		\begin{itemize}
			\item Make a \texttt{Person} interface with methods (or properties with only a getter):
			\begin{itemize}
				\item Name
				\item Surname
				\item Age
			\end{itemize}
			
			\item Make the \texttt{Customer}, \texttt{Student}, \texttt{Teacher} implementations of \texttt{Person}, ensuring that they all get at least three additional methods and attributes over those in \texttt{Person}		
		\end{itemize}

		\paragraph{Reuse through generics}
		\begin{itemize}
			\item (\textbf{Advanced}) Make a \texttt{List<T>} interface with methods \texttt{Length}, \texttt{Iterate}, \texttt{Map}, and \texttt{Filter}
			\item (\textbf{Advanced}) Define the concrete classes \texttt{Node<T>} and \texttt{Empty<T>} both implementing \texttt{List<T>}
			\item (\textbf{Advanced}) Make a \texttt{List<Vehicle>}, fill it with a series of concrete vehicles, and make them all move ten times
			\item Make a generic \texttt{Number<N>} abstract class, with methods:
			\begin{itemize}
				\item \texttt{Zero} that returns an \texttt{N}
				\item \texttt{One} that returns an \texttt{N}
				\item abstract methods \texttt{Negate}, that takes an \texttt{N} and returns an \texttt{N} (for example \texttt{Negate(1)} return \texttt{-1})
				- Plus, Times, DividedBy that all take two N's and returns an N
				\item The non-abstract method \texttt{Minus} that makes use of \texttt{Plus} and \texttt{Negate}
				\item abstract methods \texttt{SmallerThan} and \texttt{Equal}, that take two \texttt{N}'s and return a \texttt{boolean}
				\item The non-abstract methods \texttt{SmallerOrEqual}, \texttt{GreaterThan}, \texttt{GreaterOrEqual}, \texttt{NotEqual}
			\end{itemize}
			
			\item Make a class \texttt{IntNumber} that implements \texttt{Number<int>}
			\item Make a class \texttt{FloatNumber} that implements \texttt{Number<float>}
			\item Try to make a class \texttt{StringNumber} that implements \texttt{Number<string}: how far can you come?
			
			\item Make the \texttt{Interval} class we have seen in the first homework of DEV3 generic with respect to the type of the parameters \texttt{l} and \texttt{u}; specifically, build a generic class \texttt{Interval<N>} which takes as input two \texttt{N}'s \texttt{l} and \texttt{u}, and also an instance of \texttt{Number<N>}
		\end{itemize}



		\paragraph{Architectural and design considerations}
		\begin{itemize}
			\item Write an \texttt{Event} abstract class or interface with a method \texttt{perform}; 
			\item Write a \texttt{Timer} class with a method \texttt{tick} and a method \texttt{reset}; \texttt{reset} restarts the timer, while \texttt{tick} makes the timer move forward and returns whether or not the target time has been reached; when the timer reaches the target time, then fire the events in the list of timer responses
			\item Make a \texttt{TrafficLight} class which uses timers to implement red, green, and yellow lights;
			\item (\textbf{Advanced}) Rebuild timers, but this time with lambda's instead of our custom \texttt{Event}.
			\item (\textbf{Advanced}) Make a \texttt{Component} interface;
			\item (\textbf{Advanced}) Make an \texttt{Entity} abstract class which houses a list of components;
			\item (\textbf{Advanced}) Write a \texttt{Car} class that inherits from \texttt{Entity} and which implements all the functionality that you would expect from a car, but with the \textit{Entity-Component} model; you will need to build components for the engine, the wheels, etc. and all that the \texttt{Car} class does is make correct use of these components.
		\end{itemize}

		\textbf{No reference solution yet:}
		\begin{itemize}
			\item Build an entity-component system where a \texttt{Person} is made up of multiple components such as shoes, clothes, make-up, personality, and intelligence (all implemented via appropriate interfaces); the \texttt{Person} then performs a few actions, such as doing sports, studying, and socializing through methods: the results of these actions depend on the components of the person so that, for example, doing sports with elegant shoes will have unpleasant results.			
		\end{itemize}

		
	
\end{document}