\setcounter{part}{3}
\part{INFDEV02-3}
\setcounter{chapter}{0}
\chapter{Introduction to object-oriented programming}

    \section{Exercises}
        \begin{enumerate}
            \item Translate the Python-program below to Java or C\#:
            \begin{lstlisting}
result = ""
for i in range(0,9):
    for j in range(0,i):
        result += "*"
    result += "\n"
print(result)
            \end{lstlisting}

            \item Write a program that draws a smiley on the console (just like in INFDEV02-1).
            \item Write an example of Python code that would cause a type error in Java/C\#
            \item Make a static function that sums all numbers between two inputs read from the console and prints the result

            \item Given all semantic and typing rules in the slides, write down in plain English or Dutch
            \item Make an \texttt{Interval} class that:
            \begin{itemize}
                \item takes two integers, \texttt{start} and \texttt{end}, as its constructor parameters
                \item has a \texttt{Sum} method that returns the sum of all numbers between \texttt{start} and \texttt{end}
                \item has a \texttt{Product} method that returns the product of all numbers between \texttt{start} and \texttt{end}
            \end{itemize}

            \item Make a class \texttt{IntArrayOpperations} that:
            \begin{itemize}
                \item takes an array of integers, as its constructor parameter
                \item has a \texttt{Sum} method that returns the sum of all numbers in the array
                \item has a \texttt{Product} method that returns the product of all numbers in the array
            \end{itemize}

            \item Write a Java/C\# program featuring
            \begin{itemize}
                \item A \texttt{Counter} class;
                \item With a \texttt{count} integer attribute;
                \item With an empty (parameterless) constructor;
                \item With a method \texttt{Reset};
                \item With a method \texttt{Tick};
                \item (\textbf{Advanced}) With a static method/overloaded operator \texttt{Plus} which adds two counters into one;
                \item (\textbf{Advanced}) With a method \texttt{OnTarget} that takes as input a lambda function which will be fired when the counter reaches a given count.
            \end{itemize}

            \item Write a Java/C\# program featuring
                \begin{itemize}
                    \item Write a class UserStory, which has:
                    \begin{itemize}
                        \item 2 variables:
                            \begin{itemize}
                                \item hours
                                \item description
                            \end{itemize}

                        \item getters and setters for those fields
                        \item a toString method
                        \item a main method that instantiates 3 UserStory-objects
                    \end{itemize}

                    \item Write a class Sprint, which has:
                         \begin{itemize}
                            \item 1 variable: an array of UserStories
                            \item methods:
                            \begin{itemize}
                                \item totalHours() which sums all the hours in the UserStories
                                \item a toString method
                                \item a main method that instantiates a Sprint-object and fills it with
                                \item addUserStory which adds a UserStory to the array of Userstories
                            \end{itemize}
                        \end{itemize}
                \end{itemize}

            \item We will revisit the UserStory- and Sprint-classes and extend them. In this exercise you will apply knowledge about constructors, collections
                \begin{enumerate}
                    \item To both classes add a constructor which sets their instance variables.
                    \item In the Sprint class: Instead of an array, use an ArrayList to store UserStories.
                    \item Sprints usually have a startdate (17th of february) and a duration (for example: 1 week). Add these variables to the class. Try and google which datatypes (classes) are suitable for storing dates and durations.
                    \item Also, add getters for the previous variables and update the constructor.
                    \item UserStories have to store their status: Todo, In progress, To verify, Done. Add a variable that can store this.
                    \item Write methods in the Sprint-class that:
                    \begin{itemize}
                         \item returns the amount of hours of work still to be done in a sprint.
                         \item returns the amount of hours already done in a sprint.
                         \item returns if the current sprint is done
                    \end{itemize}
                    \item (Optional) The datatype you chose for the status (Todo, Done, etc.) is probably a String, right? Readup\footnote{\href{https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html}{https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html}} on Enums, a special type and use an enum to store the status.
                \end{enumerate}
    \end{enumerate}

\chapter{Reuse through polymorphism}
    \section{Exercises}
        \begin{itemize}
            \item Write a \texttt{Vehicle} interface with a method \texttt{move} and a method \texttt{loadFuel}; \texttt{loadFuel} accepts a \texttt{Fuel} instance, where \texttt{Fuel} is an interface of your writing; \texttt{move} returns a boolean which is \texttt{true} if there is enough fuel, and \texttt{false} otherwise
            \item Write a concrete class \texttt{Car} and a concrete class \texttt{Gasoline} that implement, respectively, \texttt{Vehicle} and \texttt{Fuel}; the \texttt{Car} checks that the given fuel is indeed \texttt{Gasoline}
            \item Write a concrete class \texttt{Truck} and a concrete class \texttt{Diesel} that implement, respectively, \texttt{Vehicle} and \texttt{Fuel}; the \texttt{Truck} checks that the given fuel is indeed \texttt{Diesel}
            \item Write a concrete class \texttt{Enterprise} and a concrete class \texttt{Dilithium} that implement, respectively, \texttt{Vehicle} and \texttt{Fuel}; the \texttt{Enterprise} checks that the given fuel is indeed \texttt{Dilithium}
            \item Make a program that receives three vehicles, without knowing their concrete type, and moves them (without resorting to conversions) until their fuel is up
        \end{itemize}

        \textbf{No reference solution yet:}
        \begin{itemize}
            \item Make a \texttt{Person} interface with methods (or properties with only a getter):
            \begin{itemize}
                \item Name
                \item Surname
                \item Age
            \end{itemize}

            \item Make the \texttt{Customer}, \texttt{Student}, \texttt{Teacher} implementations of \texttt{Person}, ensuring that they all get at least three additional methods and attributes over those in \texttt{Person}
        \end{itemize}

\chapter{Reuse through generics}
    \section{Exercises}
        \begin{itemize}
            \item (\textbf{Advanced}) Make a \texttt{List<T>} interface with methods \texttt{Length}, \texttt{Iterate}, \texttt{Map}, and \texttt{Filter}
            \item (\textbf{Advanced}) Define the concrete classes \texttt{Node<T>} and \texttt{Empty<T>} both implementing \texttt{List<T>}
            \item (\textbf{Advanced}) Make a \texttt{List<Vehicle>}, fill it with a series of concrete vehicles, and make them all move ten times
            \item Make a generic \texttt{Number<N>} abstract class, with methods:
            \begin{itemize}
                \item \texttt{Zero} that returns an \texttt{N}
                \item \texttt{One} that returns an \texttt{N}
                \item abstract methods \texttt{Negate}, that takes an \texttt{N} and returns an \texttt{N} (for example \texttt{Negate(1)} return \texttt{-1})
                - Plus, Times, DividedBy that all take two N's and returns an N
                \item The non-abstract method \texttt{Minus} that makes use of \texttt{Plus} and \texttt{Negate}
                \item abstract methods \texttt{SmallerThan} and \texttt{Equal}, that take two \texttt{N}'s and return a \texttt{boolean}
                \item The non-abstract methods \texttt{SmallerOrEqual}, \texttt{GreaterThan}, \texttt{GreaterOrEqual}, \texttt{NotEqual}
            \end{itemize}

            \item Make a class \texttt{IntNumber} that implements \texttt{Number<int>}
            \item Make a class \texttt{FloatNumber} that implements \texttt{Number<float>}
            \item Try to make a class \texttt{StringNumber} that implements \texttt{Number<string}: how far can you come?

            \item Make the \texttt{Interval} class we have seen in the first homework of DEV3 generic with respect to the type of the parameters \texttt{l} and \texttt{u}; specifically, build a generic class \texttt{Interval<N>} which takes as input two \texttt{N}'s \texttt{l} and \texttt{u}, and also an instance of \texttt{Number<N>}
        \end{itemize}



\chapter{Architectural and design considerations}
    \section{Exercises}

        \begin{itemize}
            \item Write an \texttt{Event} abstract class or interface with a method \texttt{perform};
            \item Write a \texttt{Timer} class with a method \texttt{tick} and a method \texttt{reset}; \texttt{reset} restarts the timer, while \texttt{tick} makes the timer move forward and returns whether or not the target time has been reached; when the timer reaches the target time, then fire the events in the list of timer responses
            \item Make a \texttt{TrafficLight} class which uses timers to implement red, green, and yellow lights;
            \item (\textbf{Advanced}) Rebuild timers, but this time with lambda's instead of our custom \texttt{Event}.
            \item (\textbf{Advanced}) Make a \texttt{Component} interface;
            \item (\textbf{Advanced}) Make an \texttt{Entity} abstract class which houses a list of components;
            \item (\textbf{Advanced}) Write a \texttt{Car} class that inherits from \texttt{Entity} and which implements all the functionality that you would expect from a car, but with the \textit{Entity-Component} model; you will need to build components for the engine, the wheels, etc. and all that the \texttt{Car} class does is make correct use of these components.
        \end{itemize}

        \textbf{No reference solution yet:}
        \begin{itemize}
            \item Build an entity-component system where a \texttt{Person} is made up of multiple components such as shoes, clothes, make-up, personality, and intelligence (all implemented via appropriate interfaces); the \texttt{Person} then performs a few actions, such as doing sports, studying, and socializing through methods: the results of these actions depend on the components of the person so that, for example, doing sports with elegant shoes will have unpleasant results.
        \end{itemize}

